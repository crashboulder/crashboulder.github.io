import * as chai from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import { MockHttpRequest } from './mocks';
import { AuthenticationService, AuthorizationHeader, buildAuthenticationHeader } from '../../src/security/';
import { GeofenceService } from '../../src/geofences/';
import { ApplicationContext } from '../../src/application-context';
import { getConfiguration } from '../../src/';

import { CURRENT_ENVIRONMENT } from '../test-constants';

let sinon = require('sinon'); // workaround for: import * as sinon from 'sinon';
let sinonChai = require('sinon-chai'); //workaround for: import * as sinonChai from 'sinon-chai';

const expect = chai.expect;
chai.use(chaiAsPromised);
chai.should();

describe('Authentication Service', function() {
  let authenticationService: AuthenticationService;
  let applicationId = 'fake-app';

  describe('given an application access token', function() {

    let accessToken = '42';
    let mockHttp = new MockHttpRequest;
    let httpPostMethodSpy: any;
    let applicationContext = new ApplicationContext('app-id', getConfiguration().secret);
    let genericService = new GeofenceService(applicationContext);

    beforeEach(function() {
      httpPostMethodSpy = sinon.spy(mockHttp, 'post');
      authenticationService = new AuthenticationService({
        applicationId: applicationId,
      }, mockHttp);
      genericService.applicationContext.applicationAccessToken = accessToken;
    });

    afterEach(function() {
      (<any>mockHttp.post).restore();
    });

    it('should be able to build Authorization headers', () => {
      let authorizationHeader = buildAuthenticationHeader(applicationContext) as AuthorizationHeader;
      authorizationHeader['Authorization'].should.equal(`Bearer ${accessToken}`);
    });

    it('should request an application access token', () => {
      let secret = getConfiguration().secret;
      let tokenRequest = authenticationService.fetchApplicationAccessToken(secret);
      return expect(tokenRequest).to.eventually.be.fulfilled.and.satisfy((responseObject: any) => {
        let postCalled = httpPostMethodSpy.calledOnce;
        let host = CURRENT_ENVIRONMENT['et-auth'];
        let properURL = `${host}/authorization/v1/${applicationId}`;
        let firstPostCall = httpPostMethodSpy.getCall(0);
        let url = firstPostCall.args[0];
        let urlIsCorrect = url === properURL;
        let config = firstPostCall.args[2];
        let headersContainSecret = config.headers['Authorization'] === secret;
        return urlIsCorrect && postCalled && headersContainSecret;
      });
    });
  });

});
