import * as _ from 'underscore';
import * as chai from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import { AxiosError, AxiosResponse } from 'axios';
import { IApplication } from '../../src/applications/';
import { ISpeedAlert, SpeedAlertService } from '../../src/speed-alerts/';
import { ApplicationContext } from '../../src/application-context';
import { getConfiguration } from '../../src/';
import { MockHttpRequest } from './mocks';
import { CURRENT_ENVIRONMENT } from '../test-constants';

const expect = chai.expect;
chai.use(chaiAsPromised);
chai.should();

describe('Speed Alert Service Test Suite: \n\n', function() {
  let speedAlertId = 'some-speed-alert';
  let applicationContext = new ApplicationContext('application', getConfiguration().secret);
  const MOCK_SPEED_ALERT:ISpeedAlert = {
    appId: 'application',
    clientId: 'client',
    speedAlertId: speedAlertId,
    maxSpeed: {
      reactions: [],
      speed: 50
    }
  };

  describe('create', function() {
    let speedAlertService: SpeedAlertService;

    beforeEach(function() {
      speedAlertService = new SpeedAlertService(applicationContext, new MockHttpRequest);
    });

    it('call the platform API to create a speed-alert rule', function() {
      return speedAlertService.create(MOCK_SPEED_ALERT).should.eventually.be.fulfilled.and.satisfy((result:any) => result.data === MOCK_SPEED_ALERT, 'contain data property with mock model');
    });

    it('should post to a properly formatted URL', function() {
      let postRequest = speedAlertService.create(MOCK_SPEED_ALERT);
      return expect(postRequest).to.eventually.be.fulfilled.and.satisfy(function(responseObject: any) {
        let host = CURRENT_ENVIRONMENT['et-rules'];
        let properURL = `${host}/speed-alerts/v1/application`;
        return responseObject.url === properURL;
      });
    });

    it('should authenticate using the application scope', () => {
      return speedAlertService.create(MOCK_SPEED_ALERT).should.eventually.satisfy((requestObject:any) => {
        return requestObject.config.headers['Authorization'] === `Bearer ${applicationContext.applicationAccessToken}`;
      });
    });

  });

  describe('#get', function() {
    let speedAlertService: SpeedAlertService;

    beforeEach(function() {
      speedAlertService = new SpeedAlertService(applicationContext, new MockHttpRequest);
    });

    it('call the platform API to get a speed-alert rule', function() {
      return speedAlertService.get(speedAlertId).should.eventually.be.fulfilled;
    });

    it('should get to a properly formatted URL', function() {
      let postRequest = speedAlertService.get(speedAlertId);
      return expect(postRequest).to.eventually.be.fulfilled.and.satisfy(function(responseObject: any) {
        let host = CURRENT_ENVIRONMENT['et-rules'];
        let properURL = `${host}/speed-alerts/v1/application/${MOCK_SPEED_ALERT.speedAlertId}`;
        return responseObject.url === properURL;
      });
    });

    it('should authenticate using the application scope', () => {
      return speedAlertService.get(speedAlertId).should.eventually.satisfy((requestObject:any) => {
        return requestObject.config.headers['Authorization'] === `Bearer ${applicationContext.applicationAccessToken}`;
      });
    });
  });

  describe('#list', function() {
    let speedAlertService: SpeedAlertService;

    beforeEach(function() {
      speedAlertService = new SpeedAlertService(applicationContext, new MockHttpRequest);
    });

    it('call the platform API to list speed-alert rules', function() {
      return speedAlertService.list({clientId: 'client'}).should.eventually.be.fulfilled;
    });

    it('should get to a properly formatted URL', function() {
      let postRequest = speedAlertService.list({clientId: 'client'});
      return expect(postRequest).to.eventually.be.fulfilled.and.satisfy(function(responseObject: any) {
        let host = CURRENT_ENVIRONMENT['et-rules'];
        let properURL = `${host}/speed-alerts/v1/application?clientId=client`;
        return responseObject.url === properURL;
      });
    });

    it('should authenticate using the application scope', () => {
      return speedAlertService.list({clientId: 'client'}).should.eventually.satisfy((requestObject:any) => {
        return requestObject.config.headers['Authorization'] === `Bearer ${applicationContext.applicationAccessToken}`;
      });
    });

  });

  describe('#delete', function() {
    let speedAlertService: SpeedAlertService;

    beforeEach(function() {
      speedAlertService = new SpeedAlertService(applicationContext, new MockHttpRequest);
    });

    it('call the platform API to delete speed-alert rules', function() {
      return speedAlertService.delete(speedAlertId).should.eventually.be.fulfilled;
    });

    it('should delete to a properly formatted URL', function() {
      let postRequest = speedAlertService.delete(speedAlertId);
      return expect(postRequest).to.eventually.be.fulfilled.and.satisfy(function(responseObject: any) {
        let host = CURRENT_ENVIRONMENT['et-rules'];
        let properURL = `${host}/speed-alerts/v1/application/${MOCK_SPEED_ALERT.speedAlertId}`;
        return responseObject.url === properURL;
      });
    });

    it('should authenticate using the application scope', () => {
      return speedAlertService.delete(speedAlertId).should.eventually.satisfy((requestObject:any) => {
        return requestObject.config.headers['Authorization'] === `Bearer ${applicationContext.applicationAccessToken}`;
      });
    });


  });
});

