import { expect } from 'chai';
import { IApplication } from '../../src/applications/';
import { IClient, ClientService } from '../../src/clients/';
import { IObservation, ObservationPayload } from '../../src/observations/';
import { AuthenticationService, AuthorizationHeader } from '../../src/security/';
import { ApplicationContext } from '../../src/application-context';
import { getConfiguration } from '../../src/';
import { CURRENT_ENVIRONMENT } from '../test-constants';
import * as _ from 'underscore';

describe('Client Service Integration: \n\n', function() {
  this.timeout(5000);
  let clientService: ClientService;
  let applicationContext = new ApplicationContext('test', getConfiguration().secret);

  const MOCK_CLIENT:IClient = {
    appId: 'test',
    clientId: `some-id-${Math.ceil(Math.random() * 9999)}`,
    label: 'mock-client'
  };

  before(function(done) {
    clientService = new ClientService(applicationContext);
    clientService.create(MOCK_CLIENT)
      .then(function(client: IClient) {
        // console.log('client created', client);
        return done();
      });
  });

  it('should rethrow a 403 when re-creating a client', (done) => {
    clientService.create(MOCK_CLIENT)
      .catch(function(e: any) {
        // console.log('client creation failed (we hope)', e);
        expect(e.status).to.equal(403);
        return done();
      });
  });

  it('can reset the secret for the client', (done) => {
    let resetCall = clientService.reset(MOCK_CLIENT);
    resetCall.then(function(model: IClient) {
      let applicationId = applicationContext.applicationId;
      let { appId, clientId, label, clientSecret:returnedClientSecret } = model;
      let appIdIsSame = appId === applicationId;
      let clientIdIsSame = clientId === MOCK_CLIENT.clientId;
      let labelIsSame = label === MOCK_CLIENT.label;
      expect(appIdIsSame && clientIdIsSame && labelIsSame && !!returnedClientSecret).to.be.true;
      // console.log({appIdIsSame, clientIdIsSame, labelIsSame, returnedClientSecret});
      return done();
    });
  });

  it('should be updateable', (done) => {
    let updatedLabel = 'updated label';
    let updatedClient = _.extend(MOCK_CLIENT, { label: updatedLabel });
    let clientUpdateCall = clientService.update(updatedClient);
    clientUpdateCall.then((result) => {
      expect(result.label).to.equal(updatedLabel);
      return done();
    }).catch((e) => {
      console.log("Problem updating", e);
      return done(e);
    });
  });

  it('should accept observations', (done) => {
    let observation:IObservation = {
      observedAt: Date.now(),
      receivedAt: Date.now()
    };
    let payload = new ObservationPayload(
      MOCK_CLIENT.clientId as string,
      [observation]
    );
    let postObservationsCall = clientService.postObservations(payload);
    postObservationsCall.then((result:any) => {
      expect(result.status).to.be.undefined;
      return done();
    }).catch((e:Error) => {
      console.log("Problem posting observation", e);
      return done(e);
    });
  });

  describe('with an existing client', () => {

    const EXISTING_CLIENT:IClient = {
      clientId: `some-id-${Math.ceil(Math.random() * 9999)}`,
      label: 'short-lived-client'
    };

    before((done) => {
      clientService.create(EXISTING_CLIENT).then((res) => {
        return done();
      });
    });

    it('should be deleteable', (done) => {
      let idOfClientToDelete = EXISTING_CLIENT.clientId as string;
      let clientDeletion = clientService.delete(idOfClientToDelete);
      clientDeletion.then((result) => {
        let deletedClientRetrieval = clientService.get(idOfClientToDelete);
        return deletedClientRetrieval
          .then((res) => {
            return done("Client " + idOfClientToDelete + " should not be retrievable");
          })
          .catch(function(fetchResult: any) {
            expect(fetchResult.response.status).to.equal(404);
            return done();
          });
      }).catch((e) => {
        console.log("Problem deleting", e);
        return done(e);
      });
    });
  });


  describe('given a fresh application context', () => {
    let freshContextWithNoToken: ApplicationContext;
    before((done) => {
      freshContextWithNoToken = new ApplicationContext('test', getConfiguration().secret);
      return done();
    });

    it('when creating a client that already exists, it should rethrow the first 403', (done) => {
        freshContextWithNoToken.clients.create(MOCK_CLIENT)
          .then(result => {
            return done(new Error("403 should not get to then block"));
          })
          .catch(function(e: any) {
            expect(e.status).to.equal(403);
            return done();
          });
        });
  });

});

