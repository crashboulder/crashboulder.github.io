import * as _ from 'underscore';
import { ApplicationContext } from '../application-context';
import { HttpRequest } from '../http/';
import { GenericService } from '../generic/service';
import { CURRENT_ENVIRONMENT } from '../environment';

export class AuthenticationServiceOptions {
  public applicationId:string;
}

export class AuthorizationHeader {
  Authorization:string;
}

export class AuthenticationService {

  public applicationId:string;

  constructor(
    protected options:AuthenticationServiceOptions,
    protected http = new HttpRequest) {
    this.applicationId = options.applicationId;
  }

  getAPIHost() {
    return CURRENT_ENVIRONMENT['et-auth'];
  }

  getRootPath() {
    return `/authorization/v1/${this.applicationId}`;
  }

  public buildAuthorizationHeader(secret:string):AuthorizationHeader {
    return { 'Authorization' : secret };
  }

  public fetchApplicationAccessToken(applicationSecret:string): Promise<string> {
    let resourceURL = this.getAPIHost() + this.getRootPath();
    let requestOptions = {
      headers: this.buildAuthorizationHeader(applicationSecret)
    };
     // console.log(resourceURL, requestOptions);
    return this.http.post<any>(resourceURL, null, requestOptions)
      .then((response:any) => response.accessToken, (error:any) => console.log(error));
  }

}

export function buildAuthenticationHeader(applicationContext: ApplicationContext):AuthorizationHeader {
  return { 'Authorization' : `Bearer ${applicationContext.applicationAccessToken}` };
}

function _handleDecoratedMethodResponse(result: any, decoratedMethod: ( options:any ) => Promise<any>, applicationContext: ApplicationContext ): Promise<any> {
  // console.log('\n\n\n', 'handle response', '\n\n\n\n');
  if ( !result ) {
    // console.error('result is empty', result);
    return Promise.resolve(result);
  } else if (!result.response) { // the case where response succedeed as expected, but response object has already been destructured
    // console.log('all good, returning result', result);
    return Promise.resolve(result);
  } else {
    let { response } = result;
    let { status } = response;
    if ( status === 403 ) return Promise.reject(response);
    else if ( status === 404 ) return Promise.reject(result);
    else if ( status === 401 ) {
      let authService = new AuthenticationService(
        { applicationId: applicationContext.applicationId }
      );
      // console.log('auth service', authService);
      return authService.fetchApplicationAccessToken(applicationContext.secret)
        .then((accessTokenResult: any) => {
          applicationContext.applicationAccessToken = accessTokenResult;
          let updatedAuthorizationHeader = buildAuthenticationHeader(applicationContext);
          let reAttemptOptions = { headers: updatedAuthorizationHeader };
          // console.log('----\n print this \n\n\n', updatedAuthorizationHeader, reAttemptOptions, '\n\n\n\n');
          return decoratedMethod(reAttemptOptions).then(recallResult => {
            let recallResponse = recallResult["response"] || {};
            let recallStatus = recallResponse["status"] || 200;
            if (recallStatus >= 403) {
              return Promise.reject(recallResponse);
            }
            return recallResult;
          });
        });
    }
    else return Promise.resolve(response);
  }
}

export function SecureRequest() {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        let decoratedMethod = descriptor.value;
        descriptor.value = function(...args: any[]) {
            let [model, options] = args;
            if (!options) options = {};
            let authenticationHeader = buildAuthenticationHeader(this.applicationContext);
            let headers = authenticationHeader;
            if ( options.headers ) headers = _.extend(options.headers, headers);
            options = {
              headers
            };

            let executeDecoratedMethod = (requestOptions: any) => decoratedMethod.apply(this, [model, _.extend(options, requestOptions)]);

            // console.log('\n secure request \n\n\n', options, '\n\n\n\n');
            return executeDecoratedMethod.bind(this)(options)
              .then((response: any) => _handleDecoratedMethodResponse(response, executeDecoratedMethod.bind(this), this.applicationContext));
        };
        return descriptor;
    };
}

export const ApplicationAccess = SecureRequest();

