"use strict";
var chai_1 = require('chai');
var _1 = require('../../src/clients/');
var _2 = require('../../src/observations/');
var application_context_1 = require('../../src/application-context');
var _3 = require('../../src/');
var _ = require('underscore');
describe('Client Service Integration: \n\n', function () {
    this.timeout(5000);
    var clientService;
    var applicationContext = new application_context_1.ApplicationContext('test', _3.getConfiguration().secret);
    var MOCK_CLIENT = {
        appId: 'test',
        clientId: "some-id-" + Math.ceil(Math.random() * 9999),
        label: 'mock-client'
    };
    before(function (done) {
        clientService = new _1.ClientService(applicationContext);
        clientService.create(MOCK_CLIENT)
            .then(function (client) {
            // console.log('client created', client);
            return done();
        });
    });
    it('should rethrow a 403 when re-creating a client', function (done) {
        clientService.create(MOCK_CLIENT)
            .catch(function (e) {
            // console.log('client creation failed (we hope)', e);
            chai_1.expect(e.status).to.equal(403);
            return done();
        });
    });
    it('can reset the secret for the client', function (done) {
        var resetCall = clientService.reset(MOCK_CLIENT);
        resetCall.then(function (model) {
            var applicationId = applicationContext.applicationId;
            var appId = model.appId, clientId = model.clientId, label = model.label, returnedClientSecret = model.clientSecret;
            var appIdIsSame = appId === applicationId;
            var clientIdIsSame = clientId === MOCK_CLIENT.clientId;
            var labelIsSame = label === MOCK_CLIENT.label;
            chai_1.expect(appIdIsSame && clientIdIsSame && labelIsSame && !!returnedClientSecret).to.be.true;
            // console.log({appIdIsSame, clientIdIsSame, labelIsSame, returnedClientSecret});
            return done();
        });
    });
    it('should be updateable', function (done) {
        var updatedLabel = 'updated label';
        var updatedClient = _.extend(MOCK_CLIENT, { label: updatedLabel });
        var clientUpdateCall = clientService.update(updatedClient);
        clientUpdateCall.then(function (result) {
            chai_1.expect(result.label).to.equal(updatedLabel);
            return done();
        }).catch(function (e) {
            console.log("Problem updating", e);
            return done(e);
        });
    });
    it('should accept observations', function (done) {
        var observation = {
            observedAt: Date.now(),
            receivedAt: Date.now()
        };
        var payload = new _2.ObservationPayload(MOCK_CLIENT.clientId, [observation]);
        var postObservationsCall = clientService.postObservations(payload);
        postObservationsCall.then(function (result) {
            chai_1.expect(result.status).to.be.undefined;
            return done();
        }).catch(function (e) {
            console.log("Problem posting observation", e);
            return done(e);
        });
    });
    describe('with an existing client', function () {
        var EXISTING_CLIENT = {
            clientId: "some-id-" + Math.ceil(Math.random() * 9999),
            label: 'short-lived-client'
        };
        before(function (done) {
            clientService.create(EXISTING_CLIENT).then(function (res) {
                return done();
            });
        });
        it('should be deleteable', function (done) {
            var idOfClientToDelete = EXISTING_CLIENT.clientId;
            var clientDeletion = clientService.delete(idOfClientToDelete);
            clientDeletion.then(function (result) {
                var deletedClientRetrieval = clientService.get(idOfClientToDelete);
                return deletedClientRetrieval
                    .then(function (res) {
                    return done("Client " + idOfClientToDelete + " should not be retrievable");
                })
                    .catch(function (fetchResult) {
                    chai_1.expect(fetchResult.response.status).to.equal(404);
                    return done();
                });
            }).catch(function (e) {
                console.log("Problem deleting", e);
                return done(e);
            });
        });
    });
    describe('given a fresh application context', function () {
        var freshContextWithNoToken;
        before(function (done) {
            freshContextWithNoToken = new application_context_1.ApplicationContext('test', _3.getConfiguration().secret);
            return done();
        });
        it('when creating a client that already exists, it should rethrow the first 403', function (done) {
            freshContextWithNoToken.clients.create(MOCK_CLIENT)
                .then(function (result) {
                return done(new Error("403 should not get to then block"));
            })
                .catch(function (e) {
                chai_1.expect(e.status).to.equal(403);
                return done();
            });
        });
    });
});
//# sourceMappingURL=clients.service.spec.js.map