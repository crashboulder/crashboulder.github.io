"use strict";
var chai = require('chai');
var chaiAsPromised = require('chai-as-promised');
var _1 = require('../../src/speed-alerts/');
var application_context_1 = require('../../src/application-context');
var _2 = require('../../src/');
var mocks_1 = require('./mocks');
var test_constants_1 = require('../test-constants');
var expect = chai.expect;
chai.use(chaiAsPromised);
chai.should();
describe('Speed Alert Service Test Suite: \n\n', function () {
    var speedAlertId = 'some-speed-alert';
    var applicationContext = new application_context_1.ApplicationContext('application', _2.getConfiguration().secret);
    var MOCK_SPEED_ALERT = {
        appId: 'application',
        clientId: 'client',
        speedAlertId: speedAlertId,
        maxSpeed: {
            reactions: [],
            speed: 50
        }
    };
    describe('create', function () {
        var speedAlertService;
        beforeEach(function () {
            speedAlertService = new _1.SpeedAlertService(applicationContext, new mocks_1.MockHttpRequest);
        });
        it('call the platform API to create a speed-alert rule', function () {
            return speedAlertService.create(MOCK_SPEED_ALERT).should.eventually.be.fulfilled.and.satisfy(function (result) { return result.data === MOCK_SPEED_ALERT; }, 'contain data property with mock model');
        });
        it('should post to a properly formatted URL', function () {
            var postRequest = speedAlertService.create(MOCK_SPEED_ALERT);
            return expect(postRequest).to.eventually.be.fulfilled.and.satisfy(function (responseObject) {
                var host = test_constants_1.CURRENT_ENVIRONMENT['et-rules'];
                var properURL = host + "/speed-alerts/v1/application";
                return responseObject.url === properURL;
            });
        });
        it('should authenticate using the application scope', function () {
            return speedAlertService.create(MOCK_SPEED_ALERT).should.eventually.satisfy(function (requestObject) {
                return requestObject.config.headers['Authorization'] === "Bearer " + applicationContext.applicationAccessToken;
            });
        });
    });
    describe('#get', function () {
        var speedAlertService;
        beforeEach(function () {
            speedAlertService = new _1.SpeedAlertService(applicationContext, new mocks_1.MockHttpRequest);
        });
        it('call the platform API to get a speed-alert rule', function () {
            return speedAlertService.get(speedAlertId).should.eventually.be.fulfilled;
        });
        it('should get to a properly formatted URL', function () {
            var postRequest = speedAlertService.get(speedAlertId);
            return expect(postRequest).to.eventually.be.fulfilled.and.satisfy(function (responseObject) {
                var host = test_constants_1.CURRENT_ENVIRONMENT['et-rules'];
                var properURL = host + "/speed-alerts/v1/application/" + MOCK_SPEED_ALERT.speedAlertId;
                return responseObject.url === properURL;
            });
        });
        it('should authenticate using the application scope', function () {
            return speedAlertService.get(speedAlertId).should.eventually.satisfy(function (requestObject) {
                return requestObject.config.headers['Authorization'] === "Bearer " + applicationContext.applicationAccessToken;
            });
        });
    });
    describe('#list', function () {
        var speedAlertService;
        beforeEach(function () {
            speedAlertService = new _1.SpeedAlertService(applicationContext, new mocks_1.MockHttpRequest);
        });
        it('call the platform API to list speed-alert rules', function () {
            return speedAlertService.list({ clientId: 'client' }).should.eventually.be.fulfilled;
        });
        it('should get to a properly formatted URL', function () {
            var postRequest = speedAlertService.list({ clientId: 'client' });
            return expect(postRequest).to.eventually.be.fulfilled.and.satisfy(function (responseObject) {
                var host = test_constants_1.CURRENT_ENVIRONMENT['et-rules'];
                var properURL = host + "/speed-alerts/v1/application?clientId=client";
                return responseObject.url === properURL;
            });
        });
        it('should authenticate using the application scope', function () {
            return speedAlertService.list({ clientId: 'client' }).should.eventually.satisfy(function (requestObject) {
                return requestObject.config.headers['Authorization'] === "Bearer " + applicationContext.applicationAccessToken;
            });
        });
    });
    describe('#delete', function () {
        var speedAlertService;
        beforeEach(function () {
            speedAlertService = new _1.SpeedAlertService(applicationContext, new mocks_1.MockHttpRequest);
        });
        it('call the platform API to delete speed-alert rules', function () {
            return speedAlertService.delete(speedAlertId).should.eventually.be.fulfilled;
        });
        it('should delete to a properly formatted URL', function () {
            var postRequest = speedAlertService.delete(speedAlertId);
            return expect(postRequest).to.eventually.be.fulfilled.and.satisfy(function (responseObject) {
                var host = test_constants_1.CURRENT_ENVIRONMENT['et-rules'];
                var properURL = host + "/speed-alerts/v1/application/" + MOCK_SPEED_ALERT.speedAlertId;
                return responseObject.url === properURL;
            });
        });
        it('should authenticate using the application scope', function () {
            return speedAlertService.delete(speedAlertId).should.eventually.satisfy(function (requestObject) {
                return requestObject.config.headers['Authorization'] === "Bearer " + applicationContext.applicationAccessToken;
            });
        });
    });
});
//# sourceMappingURL=speed-alerts.service.spec.js.map