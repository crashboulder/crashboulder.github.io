// import {
//   HttpRequest,
//   Http
// } from '../http/';
// /**
//  * Copy properties of source object to target object excluding constructor.
//  * If a property with the same exists on the target it is NOT overwritten.
//  *
//  * @param target
//  * @param source
//  */
// export function extend(target:any, source:any) {
//     // console.log('extend', target, source);
//     Object.getOwnPropertyNames(source).forEach( name => {
//         if (name!=='constructor' && !target.hasOwnProperty(name)) {
//             Object.defineProperty(target, name,
//                 Object.getOwnPropertyDescriptor(source, name));
//         }
//     });
// }
// /**
//  * Create a constructor function for a class implementing the given mixins.
//  *
//  * @param defaultOptions options that will be used if some options are missing at construction time
//  * @param mixins array of classes to be mixed together. The constructor of those classes will receive the options given
//  *               to the constructor of the composed object
//  * @returns {{new(any): {}}} a constructor function
//  */
// export function compose(defaultOptions: any, mixins: any[]): any {
// //   console.log(defaultOptions, mixins);
//   var generatedConstructor = function(options: any) {
//     // console.log(options, this);    
//     var objectReference: any = {};
//     if ( options ) { extend(objectReference, options); }
//     if ( defaultOptions ) { extend(objectReference, defaultOptions); }
//     //call constructor for each mixin
//     mixins.forEach((mixin:any) =>
//       mixin.call(this, ...objectReference));
//   };
//   //add all mixin properties and methods for all created objects
//   mixins.forEach((mixin:any) => {
//     // console.log('foreach', mixins, '\n\n', mixin, '\n\n');
//     return extend(generatedConstructor.prototype, mixin.prototype);
//   });
// //   mixins.forEach((mixin:any) => 
// //     extend(generatedConstructor.prototype, mixin.prototype));
//   return generatedConstructor;
// }
// export interface IGeofence {
//   id?:string;
//   clientId: string;
//   region: any;
//   reactions: Array<any>;
// }
// export interface IDataService<T> {
//   save():Promise<T>;
// }
// export interface IGeofenceService extends IDataService<IGeofence> {
// }
// export class GeofenceService implements IGeofenceService {
//   public http: HttpRequest;
//   constructor(options: GeofenceRecordConstructorOptions) {
//       this.http = options.http || new HttpRequest;
//   }
//   getModel() {
//       const _this: any = this;
//       return (_this as IGeofence);
//   }
//   save(): Promise<IGeofence> {
//     // TODO: replace 'appId' with actual application ID that was configured
//     // TODO: add Authentication headers (with app secret)
//     console.log('calling geofence service save');
//     return this.http.post<IGeofence>('/geofences/v1/appId', this.getModel());
//   }
// }
// export class GeofenceModel implements IGeofence {
//     public clientId: string;
//     public region: any;
//     public reactions: Array<any>;
//     public service: IGeofenceService;
//     constructor(options: GeofenceRecordConstructorOptions) {
//         let { clientId, region, reactions, service } = options;
//         this.clientId = clientId;
//         this.region = region;
//         this.reactions = reactions;
//         this.service = service || new GeofenceService(options);
//     }
// }
// export interface GeofenceRecordConstructorOptions {
//     clientId:string;
//     region: any;
//     reactions: Array<any>;
//     service?: IGeofenceService;
//     http?: HttpRequest;
// }
// export interface IGeofenceRecord extends IGeofence, IGeofenceService {
//   new(options: GeofenceRecordConstructorOptions):IGeofenceRecord;
//   (options: GeofenceRecordConstructorOptions):void;
// }
// export var IGeofenceRecord = compose({
//     clientId: '', region: {}, reactions: []
// }, [GeofenceModel, GeofenceService]) as IGeofenceRecord;
// export class Geofence extends IGeofenceRecord {
//   constructor(options: GeofenceRecordConstructorOptions) {
//       super(options);
//   }
// }
// export interface IConstructable<T, K extends Object> {
//     new(properties:T): K;
//     // (options: T): void;
//     prototype?: K;
// }
// export function BuildMixedClass
//     <ConstructorOptions,
//     TypedInterface extends IConstructable<ConstructorOptions, any>>
//         (constructorOptions:ConstructorOptions, ...composingClasses: any[]): TypedInterface {
//             var mixedInterface: IConstructable<Object, Object> = compose(constructorOptions, composingClasses) as TypedInterface;
//             // console.log('building mixed interface', mixedInterface, composingClasses);
//             var mixedClass = class MixedClass extends mixedInterface {
//                 constructor(constructorOptions: ConstructorOptions) {
//                     super(constructorOptions);
//                     // console.log('constructing mixed type', constructorOptions, this);
//                 }
//             };
//             return mixedClass as TypedInterface;
//         }
// export interface IRESTfulRecord<ConstructorOptions, Model> extends IConstructable<ConstructorOptions, IRESTfulRecord<ConstructorOptions, Model>> {
//     create(model?: Model): Promise<IRESTfulRecord<ConstructorOptions, Model>>;
//     destroy(): Promise<boolean>;
//     list(...query: any[]): Promise<IRESTfulRecord<ConstructorOptions, Model>[]>;
//     // [key: string]: any;
// }
// export interface IDeviceProperties {
//     appId: string;
//     clientId: string;
// }
// export interface IDeviceModel extends IDeviceProperties { }
// export interface IDeviceRecord extends IDeviceModel, IRESTfulRecord<IDeviceProperties, IDeviceRecord> { }
// export class DeviceModel implements IDeviceModel {
//     public appId: string;
//     public clientId: string;
//     constructor(properties: IDeviceProperties) {
//         let { appId, clientId } = properties;
//         this.appId = appId;
//         this.clientId = clientId;
//     }
// }
// export var DeviceConstructor: IConstructable<IDeviceProperties, IDeviceRecord> = compose({}, [DeviceModel]);
// export class DeviceService extends DeviceConstructor implements IDeviceRecord {
//     create(model: IDeviceModel = this) {
//         return Http.post<IDeviceRecord>(`/v1/devices/${model.appId}`, model);
//     }
//     destroy() {
//         return Http.delete<boolean>('/v1/devices/');
//     }
//     list() {
//         let url = '/v1/devices/';
//         return Http.get<IDeviceRecord[]>(url);
//     }
// }
// export const DeviceRecord: IDeviceRecord = BuildMixedClass<IDeviceProperties, IDeviceRecord>({ appId: '', clientId: ''}, DeviceModel, DeviceService);
// // Observation Types
// export interface IObservationProperties {
//     clientId: string;
// }
// export interface IObservationModel extends IObservationProperties { }
// export interface IObservationRecord extends IObservationModel, IRESTfulRecord<IObservationProperties, IObservationRecord> { }
// export class ObservationModel implements IObservationModel {
//     public clientId: string;
//     constructor(properties: IObservationProperties) {
//         let { clientId } = properties;
//         this.clientId = clientId;
//     }
// }
// export var ObservationRecordConstructor: IConstructable<IObservationProperties, IObservationRecord> = compose({}, [ObservationModel]);
// export class ObservationService extends ObservationRecordConstructor implements IObservationRecord {
//     constructor(properties: IObservationProperties) {
//         super(properties);
//     }
//     create(model: IObservationModel = this) {
//         return Http.post<IObservationRecord>('', model);
//     }
//     destroy() {
//         return Http.delete<boolean>('');
//     }
//     list() {
//         return Http.get<IObservationRecord[]>('');
//     }
// }
// export const ObservationRecord: IObservationRecord = BuildMixedClass<IObservationProperties, IObservationRecord>({ clientId: ''}, ObservationModel, ObservationService);
// export interface IGenericProperties {
//     [key:string]: any;
// }
// export class GenericModel implements IGenericProperties {
//     private http: HttpRequest;
//     constructor(properties: IGenericProperties) {
//         let {http} = properties;
//         this.http = http || new HttpRequest;
//     }
// }
// export interface IGenericRecord<T> extends IGenericProperties, IRESTfulRecord<IGenericProperties, T> { }
// export var GenericConstructor: IConstructable<IGenericProperties, IGenericRecord<IGenericProperties>> = compose({}, [GenericModel]);
// export class GenericService<T> extends GenericConstructor implements IGenericRecord<T> {
//     constructor(properties: IGenericProperties) {
//         super(properties);
//     }
//     create(data?: T): Promise<IGenericRecord<T>> {
//         let http = (<HttpRequest>this['http']);
//         return http.post<IGenericRecord<T>>('', data);
//     }
//     destroy():Promise<boolean> {
//         let http = (<HttpRequest>this['http']);
//         // let { id } = this;
//         return http.delete<boolean>('');
//     }
//     list() {
//         let http = (<HttpRequest>this['http']);
//         return http.get<IGenericRecord<T>[]>('');
//     }
//     get(id: string) {
//         let http = (<HttpRequest>this['http']);
//         return http.get<IGenericRecord<T>>('');
//     }
// } 
//# sourceMappingURL=domain-model-plus-service-mixin.js.map