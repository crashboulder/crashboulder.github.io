"use strict";
var _ = require('underscore');
var _1 = require('../http/');
var environment_1 = require('../environment');
var AuthenticationServiceOptions = (function () {
    function AuthenticationServiceOptions() {
    }
    return AuthenticationServiceOptions;
}());
exports.AuthenticationServiceOptions = AuthenticationServiceOptions;
var AuthorizationHeader = (function () {
    function AuthorizationHeader() {
    }
    return AuthorizationHeader;
}());
exports.AuthorizationHeader = AuthorizationHeader;
var AuthenticationService = (function () {
    function AuthenticationService(options, http) {
        if (http === void 0) { http = new _1.HttpRequest; }
        this.options = options;
        this.http = http;
        this.applicationId = options.applicationId;
    }
    AuthenticationService.prototype.getAPIHost = function () {
        return environment_1.CURRENT_ENVIRONMENT['et-auth'];
    };
    AuthenticationService.prototype.getRootPath = function () {
        return "/authorization/v1/" + this.applicationId;
    };
    AuthenticationService.prototype.buildAuthorizationHeader = function (secret) {
        return { 'Authorization': secret };
    };
    AuthenticationService.prototype.fetchApplicationAccessToken = function (applicationSecret) {
        var resourceURL = this.getAPIHost() + this.getRootPath();
        var requestOptions = {
            headers: this.buildAuthorizationHeader(applicationSecret)
        };
        // console.log(resourceURL, requestOptions);
        return this.http.post(resourceURL, null, requestOptions)
            .then(function (response) { return response.accessToken; }, function (error) { return console.log(error); });
    };
    return AuthenticationService;
}());
exports.AuthenticationService = AuthenticationService;
function buildAuthenticationHeader(applicationContext) {
    return { 'Authorization': "Bearer " + applicationContext.applicationAccessToken };
}
exports.buildAuthenticationHeader = buildAuthenticationHeader;
function _handleDecoratedMethodResponse(result, decoratedMethod, applicationContext) {
    // console.log('\n\n\n', 'handle response', '\n\n\n\n');
    if (!result) {
        // console.error('result is empty', result);
        return Promise.resolve(result);
    }
    else if (!result.response) {
        // console.log('all good, returning result', result);
        return Promise.resolve(result);
    }
    else {
        var response = result.response;
        var status_1 = response.status;
        if (status_1 === 403)
            return Promise.reject(response);
        else if (status_1 === 404)
            return Promise.reject(result);
        else if (status_1 === 401) {
            var authService = new AuthenticationService({ applicationId: applicationContext.applicationId });
            // console.log('auth service', authService);
            return authService.fetchApplicationAccessToken(applicationContext.secret)
                .then(function (accessTokenResult) {
                applicationContext.applicationAccessToken = accessTokenResult;
                var updatedAuthorizationHeader = buildAuthenticationHeader(applicationContext);
                var reAttemptOptions = { headers: updatedAuthorizationHeader };
                // console.log('----\n print this \n\n\n', updatedAuthorizationHeader, reAttemptOptions, '\n\n\n\n');
                return decoratedMethod(reAttemptOptions).then(function (recallResult) {
                    var recallResponse = recallResult["response"] || {};
                    var recallStatus = recallResponse["status"] || 200;
                    if (recallStatus >= 403) {
                        return Promise.reject(recallResponse);
                    }
                    return recallResult;
                });
            });
        }
        else
            return Promise.resolve(response);
    }
}
function SecureRequest() {
    return function (target, propertyKey, descriptor) {
        var decoratedMethod = descriptor.value;
        descriptor.value = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var model = args[0], options = args[1];
            if (!options)
                options = {};
            var authenticationHeader = buildAuthenticationHeader(this.applicationContext);
            var headers = authenticationHeader;
            if (options.headers)
                headers = _.extend(options.headers, headers);
            options = {
                headers: headers
            };
            var executeDecoratedMethod = function (requestOptions) { return decoratedMethod.apply(_this, [model, _.extend(options, requestOptions)]); };
            // console.log('\n secure request \n\n\n', options, '\n\n\n\n');
            return executeDecoratedMethod.bind(this)(options)
                .then(function (response) { return _handleDecoratedMethodResponse(response, executeDecoratedMethod.bind(_this), _this.applicationContext); });
        };
        return descriptor;
    };
}
exports.SecureRequest = SecureRequest;
exports.ApplicationAccess = SecureRequest();
//# sourceMappingURL=index.js.map